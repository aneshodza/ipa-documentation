% see A1.4
\chapter{Planen}

Die Zeitplanung wird in der Abbildung \ref{fig:timeplan} oberhalb gezeigt. Die restlichen Aspekte der Planung sind in diesem Kapitel dokumentiert.

\begin{figure}[H]
  \begin{center}
    \begin{tikzpicture}
      \begin{umlsystem}[x=0, y=0]{PkOrg}
      \end{umlsystem}
      \umlactor[x=-5, y=.1]{Verantwortliche Fachperson}
      \umlactor[x=5, y=.1]{Hauptexperte}
      \umlassoc{Verantwortliche Fachperson}{PkOrg}
      \umlassoc{Hauptexperte}{PkOrg}
    \end{tikzpicture}
  \end{center}
  \caption[\enquote{Systemkontextdiagramm} erstellt mit Tikz UML]{Systemkontextdiagramm}
  \label{fig:systemcontext}
\end{figure}

\section{Diagramme}
In diesem Abschnitt werden verschiedene Diagramme, welche zur bildlichen Darstellung des Systemes dienen sollen.
\subsection{Entity-Relationship-Diagram}
\subsection{Activity-Diagram}

\section{Testkonzept}
Das Testkonzept beschreibt, wie und mit welchen Werkzeugen das Resultat auf seine Richtigkeit kontrolliert wird.

\subsection{Automatisierte Tests}
Es werden automatisierte Tests für das Plugin geschrieben, welche die Funktionalität der Applikation testen.
Diese werden mit den gleichen Frameworks wie die vom Redmine geschrieben. Das heisst, dass die Tests mit
folgenden Frameworks geschrieben werden:
\begin{itemize}
  \item \textbf{MiniTest} für die Unit-Tests
  \item \textbf{Capybara} für die System-Tests
\end{itemize}
Die coverage sollte 100\% betragen (bei Klassen über 5 Zeilen). Diese Tests werden dann automatisch auf 
SemaphoreCI ausgeführt. Von der CI erhalten wir dann einen Coverage-Report, sowie eine Liste der
fehlgeschlagenen Tests. Nur falls alles in Ordnung ist, kann man die Pull-Request mergen.
\subsubsection{Weitere Tools}
Tools, welche nicht von Redmine selbst verwendet werden, welche aber dennoch im Plugin verwendet werden sind:
\begin{itemize}
  \item \textbf{Faker} für das Erstellen von realistischen Testdaten.
  \item \textbf{FactoryBot} für das Initialisieren von Objekten.
\end{itemize}
Die Coverage, sowie andere wichtige Informationen werden unter \ref{sec:automated-tests} dokumentiert.

\subsection{Manuelle Tests}
Während der Entwicklung und für allfällige Demonstrationszwecke werden manuelle Tests durchgeführt. Diese
werden in diesem Kapitel beschrieben und unter \ref{sec:manual-tests} protokolliert.

\begin{minipage}{\textwidth}
  \subsubsection{Verarbeiten von SemaphoreCI Daten}
  Um die Verarbeitung von SemaphoreCI Daten zu testen, gibt es zwei offensichtliche Möglichkeiten:
  \begin{itemize}
    \item \st{Senden von Daten per HTTP-Request an den lokalen Server}
    \item Benützen des Dienstes, damit dieser die Daten schickt
  \end{itemize}
  \textbf{Senden von Daten per HTTP-Request an den lokalen Server} \\
  Option eins ist das manuelle Senden von Daten an den lokalen Server. Dies kann man in der Konsole mit dem curl Programm
  \cite{everything_curl} machen. Dies ist jedoch eine sehr aufwändige und ungenaue Art zu testen, weshalb diese Option nicht
  weiter verfolgt wird. \newline

  \textbf{Benützen des Dienstes, damit dieser die Daten schickt} \\
  Die zweite Option ist, ein Repository auf GitHub zu erstellen und dieses mit SemaphoreCI zu verbinden. Es würde ein Deploy
  Script aufgesetzt werden, welches die SemaphoreCI Hooks auslöst. \newline
  Damit dann diese Daten beim lokalen Server ankommen können, müsste man mit ngrok \cite{ngrok_http_docs} einen HTTP Tunnel
  erstellen, welcher eine öffentliche IP zur Verfügung stellt. \newline
  Diese Methode ist auch sehr aufwändig, doch liefert genauere Daten als Option eins, weshalb diese benutzt wird. \newline
\end{minipage}

\begin{minipage}{\textwidth}
  \subsubsection{Verarbeiten von GitHub Daten}
  Auch die Verarbeitung der GitHub Daten kann man auf die gleiche Arten testen:
  \begin{itemize}
    \item \st{Senden von Daten per HTTP-Request an den lokalen Server}
    \item Benützen des Dienstes, damit dieser die Daten schickt \newline
  \end{itemize}
  \textbf{Senden von Daten per HTTP-Request an den lokalen Server} \\
  Die erste Option wird hier auch aus dem gleichen Grund wie bei SemaphoreCI nicht weiter verfolgt. \newline

  \textbf{Benützen des Dienstes, damit dieser die Daten schickt} \\
  Auch hier ist diese Option besser, da es zwar auch aufwändig ist, aber genauere Daten liefert. \newline
  Das Repository muss nicht mehr mit SemaphoreCI verbunden werden, doch gleich wie bei den SemaphoreCI Tests, müsse man
  mit ngrok \cite{ngrok_http_docs} einen HTTP Tunnel erstellen, welcher eine öffentliche IP zur Verfügung stellt.
\end{minipage}
\subsubsection{Der Nutzer schaut sich ein Ticket an mit Daten}
\subsubsection{Der Nutzer schaut sich ein Ticket an ohne Daten}

\subsection{Testmittel}
