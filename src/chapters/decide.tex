\chapter{Entscheiden}
\label{chap:decide}
In diesem Kapitel werden Entscheidungen und dessen Begründungen dokumentiert. \newline
Da diese PA ein Plugin für bereits etablierte Software ist, gibt es, vor allem bezüglich des Tech-Stacks, nicht viel zu
entscheiden. Wie die zweite Software-Design Anforderung besagt: \enquote{Das Plugin soll sich an die Coding-Guidelines von
Redmine halten...}

\section{Bewertungen}
\subsection{Entity-Relationship-Diagram}
\subsubsection{Option 1: Mehrere Entitäten}
Die erste Option, wie auf Grafik \ref{fig:erd_multiple} zu sehen, ist, dass für Deployments und Pull-Requests
eigene Entitäten erstellt werden, welche beide direkt mit den Issues verbunden sind. \newline
Die Vorteile dieser Option sind beispielsweise, dass die Komplexität der Datenstruktur gering ist. Es ist einfach zu
implementieren und eventuellen späteren Entwicklern zu erklären. \newline
Ein grosser Nachteil dieser Datenstruktur ist, dass wahrscheinlich zwei separate Kontroller erstellt werden müssen, was
die Codebase unnötig vergrössert (aber nicht unbedingt Komplexität hinzufügt). \newline

\subsubsection{Option 2: Inheritance}
Die zweite Option, wie auf Grafik \ref{fig:erd_inheritance} zu sehen, ist, dass für Deployments und Pull-Requests nur
Child-Entitäten erstellt werden, welche beide von einer gemeinsamen Entität erben. \newline
Der grösste Vorteil dieser Option ist, dass die Vererbung die Codebase vereinfachen kann, falls richtig implementiert.
\newline
Nachteile sind, dass die Komplexität der Datenstruktur massiv erhöht wird. Vererbung ist in Datenbanken nicht üblich, was
implementationen davon erschwert. Rails würde dabei einen grossen Teil er Arbeit abnehmen, dennoch bleibt die Komplexität
hoch.

\subsubsection{Option 3: Has many through}
Die dritte und letzte Option, dargestellt auf Grafik \ref{fig:erd_has_many_through}, ist die am meisten an Rails angelehnte
Methode. Dabei wäre ein Deployment nicht mehr mit dem Issue, sondern der Pull Request verbunden. Die Verbindung zwischen
einem Issue und einem Deployment würde somit \enquote{durch} die Pull Request gehen. Deswegen das \enquote{through} im Namen.
Diese Option ist möglich, da wir Pull Requests deployen und nicht Issues. \newline
Vorteilhaftig wäre, dass die Datenstruktur besser die Realität abbildet. In der Realität wird eine Pull Request deployed,
was in der Datenstruktur auch so dargestellt wäre. \newline
Ein grosses Problem an diesem Ansatz ist, dass diese Option sehr viel von der Datenbank lesen muss. Bei grossen Systemen
kann das eventuell zu Performance-Problemen führen.

\subsection{Activity-Diagram}
Die Acticity-Diagramme unter Kapitel \ref{sec:activity_diagram} zeigen mehr oder weniger die einzige Möglichkeit auf den
Prozess zu gestalten. Im Design dieses Projektes muss man sich viel externen Prozessen anpassen; Redmine gibt den
Issue-Prozess vor und GitHub sowie SemaphoreCI die Webhook Prozesse.

\section{Entscheidungen}
